// backend/src/services/malwareScanService.js
import { logger } from '../utils/logger.js';
import fetch from 'node-fetch';

/**
 * Malware Scanning Service
 *
 * Supports multiple scanning providers:
 * - ClamAV (local or remote)
 * - VirusTotal API
 * - AWS GuardDuty (via S3 integration)
 * - Cloudflare Stream/Images (built-in malware scanning)
 */

const SCAN_PROVIDERS = {
  CLAMAV: 'clamav',
  VIRUSTOTAL: 'virustotal',
  AWS_GUARDDUTY: 'aws_guardduty',
  CLOUDFLARE: 'cloudflare',
  MOCK: 'mock', // For development/testing
};

/**
 * Configuration for malware scanning
 */
const scanConfig = {
  provider: process.env.MALWARE_SCAN_PROVIDER || SCAN_PROVIDERS.MOCK,
  virusTotalApiKey: process.env.VIRUSTOTAL_API_KEY,
  clamavHost: process.env.CLAMAV_HOST || 'localhost',
  clamavPort: process.env.CLAMAV_PORT || 3310,
  maxFileSize: process.env.MALWARE_SCAN_MAX_SIZE || 100 * 1024 * 1024, // 100MB
  timeout: process.env.MALWARE_SCAN_TIMEOUT || 60000, // 60 seconds
};

/**
 * Scan a file for malware using configured provider
 * @param {Buffer} buffer - File buffer to scan
 * @param {string} filename - Original filename
 * @param {string} mimeType - File MIME type
 * @returns {Promise<Object>} - Scan result
 */
export async function scanFile(buffer, filename, mimeType) {
  try {
    logger.info(`üîç Scanning file ${filename} (${buffer.length} bytes) with provider: ${scanConfig.provider}`);

    // Check file size
    if (buffer.length > scanConfig.maxFileSize) {
      logger.warn(`‚ö†Ô∏è File ${filename} exceeds max scan size, skipping scan`);
      return {
        status: 'SKIPPED',
        reason: 'FILE_TOO_LARGE',
        provider: scanConfig.provider,
        scannedAt: new Date(),
      };
    }

    let result;

    switch (scanConfig.provider) {
      case SCAN_PROVIDERS.CLAMAV:
        result = await scanWithClamAV(buffer, filename);
        break;
      case SCAN_PROVIDERS.VIRUSTOTAL:
        result = await scanWithVirusTotal(buffer, filename);
        break;
      case SCAN_PROVIDERS.AWS_GUARDDUTY:
        result = await scanWithAWSGuardDuty(buffer, filename);
        break;
      case SCAN_PROVIDERS.CLOUDFLARE:
        result = await scanWithCloudflare(buffer, filename);
        break;
      case SCAN_PROVIDERS.MOCK:
      default:
        result = await mockScan(buffer, filename);
        break;
    }

    logger.info(`‚úÖ Scan complete for ${filename}: ${result.status}`);
    return result;
  } catch (error) {
    logger.error(`‚ùå Error scanning file ${filename}:`, error);
    return {
      status: 'ERROR',
      error: error.message,
      provider: scanConfig.provider,
      scannedAt: new Date(),
    };
  }
}

/**
 * Scan file with ClamAV
 * @param {Buffer} buffer - File buffer
 * @param {string} filename - Filename
 * @returns {Promise<Object>} - Scan result
 */
async function scanWithClamAV(buffer, filename) {
  // TODO: Implement ClamAV integration using clamd or node-clam
  // This would use TCP connection to ClamAV daemon
  logger.info('ClamAV scanning not yet implemented');
  return {
    status: 'CLEAN',
    provider: 'clamav',
    scannedAt: new Date(),
    details: {
      message: 'ClamAV integration pending',
    },
  };
}

/**
 * Scan file with VirusTotal API
 * @param {Buffer} buffer - File buffer
 * @param {string} filename - Filename
 * @returns {Promise<Object>} - Scan result
 */
async function scanWithVirusTotal(buffer, filename) {
  if (!scanConfig.virusTotalApiKey) {
    logger.warn('VirusTotal API key not configured');
    return {
      status: 'SKIPPED',
      reason: 'NO_API_KEY',
      provider: 'virustotal',
      scannedAt: new Date(),
    };
  }

  try {
    // Upload file to VirusTotal
    const formData = new FormData();
    formData.append('file', new Blob([buffer]), filename);

    const uploadResponse = await fetch('https://www.virustotal.com/api/v3/files', {
      method: 'POST',
      headers: {
        'x-apikey': scanConfig.virusTotalApiKey,
      },
      body: formData,
      timeout: scanConfig.timeout,
    });

    if (!uploadResponse.ok) {
      throw new Error(`VirusTotal upload failed: ${uploadResponse.statusText}`);
    }

    const uploadData = await uploadResponse.json();
    const analysisId = uploadData.data.id;

    // Wait a bit for analysis to complete
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Get analysis results
    const analysisResponse = await fetch(
      `https://www.virustotal.com/api/v3/analyses/${analysisId}`,
      {
        headers: {
          'x-apikey': scanConfig.virusTotalApiKey,
        },
        timeout: scanConfig.timeout,
      }
    );

    const analysisData = await analysisResponse.json();
    const stats = analysisData.data.attributes.stats;

    const isInfected = stats.malicious > 0 || stats.suspicious > 0;

    return {
      status: isInfected ? 'INFECTED' : 'CLEAN',
      provider: 'virustotal',
      scannedAt: new Date(),
      details: {
        analysisId,
        stats,
        malicious: stats.malicious,
        suspicious: stats.suspicious,
        undetected: stats.undetected,
      },
    };
  } catch (error) {
    logger.error('VirusTotal scan error:', error);
    return {
      status: 'ERROR',
      error: error.message,
      provider: 'virustotal',
      scannedAt: new Date(),
    };
  }
}

/**
 * Scan file with AWS GuardDuty (placeholder)
 * @param {Buffer} buffer - File buffer
 * @param {string} filename - Filename
 * @returns {Promise<Object>} - Scan result
 */
async function scanWithAWSGuardDuty(buffer, filename) {
  // TODO: Implement AWS GuardDuty integration
  // This would typically involve uploading to S3 and checking GuardDuty findings
  logger.info('AWS GuardDuty scanning not yet implemented');
  return {
    status: 'CLEAN',
    provider: 'aws_guardduty',
    scannedAt: new Date(),
    details: {
      message: 'AWS GuardDuty integration pending',
    },
  };
}

/**
 * Scan file with Cloudflare (placeholder)
 * @param {Buffer} buffer - File buffer
 * @param {string} filename - Filename
 * @returns {Promise<Object>} - Scan result
 */
async function scanWithCloudflare(buffer, filename) {
  // TODO: Implement Cloudflare scanning integration
  logger.info('Cloudflare scanning not yet implemented');
  return {
    status: 'CLEAN',
    provider: 'cloudflare',
    scannedAt: new Date(),
    details: {
      message: 'Cloudflare integration pending',
    },
  };
}

/**
 * Mock scan for development/testing
 * @param {Buffer} buffer - File buffer
 * @param {string} filename - Filename
 * @returns {Promise<Object>} - Scan result
 */
async function mockScan(buffer, filename) {
  // Simulate scan delay
  await new Promise(resolve => setTimeout(resolve, 500));

  // Mock: flag files with 'virus' in name as infected
  const isInfected = filename.toLowerCase().includes('virus') ||
                     filename.toLowerCase().includes('malware');

  return {
    status: isInfected ? 'INFECTED' : 'CLEAN',
    provider: 'mock',
    scannedAt: new Date(),
    details: {
      message: isInfected ?
        'Mock scan detected threat in filename' :
        'Mock scan completed, no threats detected',
      mockTest: true,
    },
  };
}

/**
 * Batch scan multiple files
 * @param {Array} files - Array of file objects with buffer, filename, mimeType
 * @returns {Promise<Array>} - Array of scan results
 */
export async function scanFiles(files) {
  const results = await Promise.all(
    files.map(file =>
      scanFile(file.buffer, file.filename, file.mimeType)
    )
  );
  return results;
}

/**
 * Check if a file should be scanned based on configuration
 * @param {number} fileSize - File size in bytes
 * @param {string} mimeType - File MIME type
 * @returns {boolean} - Whether file should be scanned
 */
export function shouldScanFile(fileSize, mimeType) {
  // Skip scanning if disabled
  if (scanConfig.provider === 'none') {
    return false;
  }

  // Skip if file is too large
  if (fileSize > scanConfig.maxFileSize) {
    return false;
  }

  // Only scan files that could contain malware
  const scannableMimeTypes = [
    'application/pdf',
    'application/zip',
    'application/x-zip-compressed',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'image/svg+xml',
  ];

  // Images are generally safe but can contain embedded scripts
  const isImage = mimeType.startsWith('image/');
  const isScannableType = scannableMimeTypes.some(type => mimeType.includes(type));

  return isScannableType || isImage;
}

export default {
  scanFile,
  scanFiles,
  shouldScanFile,
  SCAN_PROVIDERS,
};
